#include "datastruct/Map.h"
#include "vigra/impex.hxx"
#include "vigra/stdimagefunctions.hxx"
#include "stats/base/diff.h"
#include "stats/base/readwritebin.h"
#include "stats/filterfunctors/BackgroundSubtractSimple.h"
#include "stats/wavems/filterrtspecdwt.h"
#include "helperfunctions.h"

namespace ralab
{
  void MMap::getSpectrum(std::size_t i,
                         std::vector<double> & mz,
                         std::vector<double> & intensities,
                         double threshold
                         ){
    typedef Map::const_row_iterator CRI;
    CRI begfiltered =mp_.rowBegin(i);
    CRI endfiltered = mp_.rowEnd(i);
    std::size_t dist = std::distance(begfiltered,endfiltered);
    mz.resize(dist);
    intensities.resize(dist);

    std::vector<double>::iterator begIntensOut =intensities.begin();
    std::vector<double>::iterator begMassOut = mz.begin();
    std::vector<double>::iterator mass = bin_.breaks_.begin();

    std::size_t countLarger = 0;
    for(; begfiltered != endfiltered; ++begfiltered, ++mass){
        if(*begfiltered > threshold)//skip values zero
          {
            ++countLarger;
            *begIntensOut = *begfiltered;
            *begMassOut = *mass;
            ++begMassOut;
            ++begIntensOut;
          }
      }
    mz.resize(countLarger);
    intensities.resize(countLarger);
  }

  /** return Retention times */
  void MMap::getRT(std::vector<double> & rt) const {
    rt.assign( retentiontime_.begin() , retentiontime_.end() );
  }

  void MMap::setRT(const std::vector<double> & rt){
    retentiontime_ = rt;
  }


  void MMap::resize( std::size_t nrows, std::size_t ncols)
  {
    mp_.resize(nrows,ncols);
  }

  void MMap::put( std::size_t row, std::size_t col, float val)
  {
    (mp_)(row,col) += val;

    if((mp_)(row,col) > maxelem_){
        maxelem_ = (mp_)(row,col);
      }
  }

  float MMap::get(std::size_t row, std::size_t col) const{
    return (mp_)(row,col);
  }

  float MMap::getMaxelem()
  {
    return maxelem_;
  }

  //TODO rename to mz or RT...
  std::size_t MMap::getNrRows() const{
    return mp_.height();
  }

  std::size_t MMap::getNrCols() const{
    return mp_.width();
  }

  /*
  void MMap::getMultipleRTs(uint32_t startcol, uint32_t endcol, std::vector<float> & signal)
  {
    uint32_t xdim = std::distance( mp_.columnBegin(startcol),mp_.columnEnd(startcol));
    uint32_t ydim  = 0;
    if(startcol < endcol)
      {
        ydim = endcol - startcol;
      }
    else
      return;
    uint32_t containersize = ydim * xdim ;
    signal.resize(containersize);

    std::vector<float>::iterator beg =signal.begin();
    for( ; startcol < endcol; ++startcol ){
        beg = std::copy(mp_.columnBegin(startcol),mp_.columnEnd(startcol),beg);
      }
  }
  */

  void MMap::computeChromNoise( std::vector<float> & res){
    std::size_t siz = mp_.width();
    res.resize(siz,0.);
    std::size_t i = 0 ;
    for( ; i < siz;  ++i ){
        std::vector<float> signal(mp_.columnBegin(i),mp_.columnEnd(i));
        std::size_t lengthsignal = signal.size();
        std::transform(signal.begin(),signal.end(),signal.begin(),boost::bind(sqrt,_1));
        std::vector<float>::iterator it =
            std::remove_if(signal.begin(), signal.end(),
                           boost::bind(std::less<double>(),_1,std::numeric_limits<float>::epsilon()) );
        signal.resize(std::distance(signal.begin(),it));

        ralab::STATS::BASE::diff(signal.begin(),signal.end(),3,2);
        if(signal.size() > 0){
            res[i] = ralab::WAVELIB::UTILITIES::UniversalThreshold( signal, lengthsignal );
          }

      }
  }

  void MMap::sumSpectrum( std::vector<float> & res){
    std::size_t siz = mp_.width();
    res.resize(siz,0.);
    std::size_t i = 0 ;
    for( ; i < siz; ++i ){
        float tmp = std::accumulate(mp_.columnBegin(i),mp_.columnEnd(i),0.);
        res[i] = tmp;
      }
  }

  //TODO limit image dimensions.
  void MMap::write_image(
      const std::string & filename,
      bool logb,
      const std::string & extension
      )
  {
    boost::filesystem::path p1 = addextension(filename,extension);
    std::cout << "writing png file : " << p1 << std::endl;
    vigra::FImage fimage;
    fimage.resize(mp_.width(),mp_.height());
    if(logb){
        std::transform(mp_.begin(), mp_.end(), fimage.begin() , boost::bind(log,boost::bind(std::plus<float>(),1,_1)));
      }else{
        std::transform(mp_.begin(), mp_.end(), fimage.begin() , boost::bind(sqrt,_1));
      }
    vigra::ImageExportInfo iei(p1.string().c_str());
    vigra::exportImage(vigra::srcImageRange(fimage),iei);
  }

  //TODO limit image dimensions.
  void MMap::write_32float(const std::string & filename,
                           const std::string & extension)
  {
    boost::filesystem::path p1 = addextension(filename,extension);
    boost::filesystem::path p2 = addextension(filename,"mass");
    std::cout << "writing vx file : " << p1 << std::endl;
    vigra::ImageExportInfo iei(p1.string().c_str());
    iei.setFileType("VIFF");
    //iei.setCompression("NONE");
    iei.setPixelType( "FLOAT" );
    vigra::exportImage(vigra::srcImageRange(mp_),iei);
    ralab::STATS::BASE::writeBin( this->bin_.getBreaks(),  p2.string());
  }


  void MMap::filterRT( ralab::STATS::IScanFilterFunctorFloatPtr  f ){
    for(std::size_t i = 0 ; i < mp_.width(); ++i)
      {
        signal_.assign( mp_.columnBegin(i), mp_.columnEnd(i) );
        (*f)( signal_ );
        std::replace_if( signal_.begin() , signal_.end() , std::bind2nd(std::less<float>(),0.),0.);
        std::copy(signal_.begin(),signal_.end(),mp_.columnBegin(i));
      }
  }

  void MMap::filterMZ( ralab::STATS::IScanFilterFunctorFloatPtr  f ){
    for(std::size_t i = 0 ; i < mp_.height(); ++i)
      {
        signal_.assign( mp_.rowBegin(i), mp_.rowEnd(i) );
        (*f)( signal_ );
        std::replace_if( signal_.begin() , signal_.end() , std::bind2nd(std::less<float>(),0.),0.);
        std::copy(signal_.begin(),signal_.end(),mp_.rowBegin(i));
      }
  }

  //you are only allowed to read vx files.
  void MMap::read(const std::string & filename){
    boost::filesystem::path p1(filename);
    if(boost::filesystem::exists(p1)){
        vigra::ImageImportInfo info( p1.string().c_str() );
        if(info.isGrayscale())
          {
            mp_.resize(info.width(), info.height());
            vigra::importImage(info, destImage(mp_));
          }
      }

    std::vector< double > mass(0);
    std::string str =  p1.stem().string() ;
    str += ".mass";
    p1 = p1.parent_path();
    p1 /= str;
    std::cout << p1.string() << " " << str << std::endl;
    ralab::STATS::BASE::readBin(p1.string(), mass);
    bin_.setBreaks(mass);
  }
}


